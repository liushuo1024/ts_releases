#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include "common/can.h"
#include <geometry_msgs/Pose.h>
#include <visualization_msgs/Marker.h>
#include <std_msgs/Bool.h>

using namespace std;
double px_recv_time =0;
double ow_recv_time;
int ow_recv_num = 0;
double rack_recv_time;
int rack_recv_num = 0;
ros::Publisher orangepi_can_pub;
ros::Publisher rack_can_pub;

ros::Subscriber can1_rx_sub;
ros::Subscriber pick_detection_enable_sub_;
ros::Subscriber unpick_detection_enable_sub_;
geometry_msgs::Pose pmsg;
geometry_msgs::Pose rmsg;
ros::Publisher marker_pub;
ros::Publisher storage_rack_marker_pub;
ros::Publisher can1_tx_pub;
int check_invalid(geometry_msgs::Pose &pose){
    if(pose.position.x == 10000){
        return -1;
    }
    if(pose.position.y == 10000){
        return -1;
    }
    if(pose.position.z == 10000){
        return -1;
    }
    if(pose.orientation.x == 10000){
        return -1;
    }
    if(pose.orientation.y == 10000){
        return -1;
    }
    if(pose.orientation.z == 10000){
        return -1;
    }
    if(pose.orientation.w == 10000){
        return -1;
    }
    return 0;

}
int set_invalid(geometry_msgs::Pose &pose){
    pose.position.x = 10000;
    pose.position.y = 10000;
    pose.position.z = 10000;
    pose.orientation.x = 10000;
    pose.orientation.y = 10000;
    pose.orientation.z = 10000;
    pose.orientation.w = 10000;
}
static void handle_orangepi_candata(const common::canConstPtr &msg)
{
    double result;
    px_recv_time = ros::Time::now().toSec();
    switch (msg->id)
    {
        case 0x100:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            pmsg.position.x = result;
            break;
        case 0x101:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            pmsg.position.y = result;
            break;
        case 0x102:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            pmsg.position.z = result;
            break;
        case 0x103:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            pmsg.orientation.x = result;
            break;
        case 0x104:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            pmsg.orientation.y = result;
            // ow_recv_time = ros::Time::now().toSec();
            break;
        case 0x105:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            pmsg.orientation.z = result;
            // ow_recv_time = ros::Time::now().toSec();
            break;
        case 0x106:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            pmsg.orientation.w = result;
            ow_recv_time = ros::Time::now().toSec();
            break;
        // 货架
        case 0x107:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            rmsg.position.x = result;
            break;
        case 0x108:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            rmsg.position.y = result;
            break;
        case 0x109:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            rmsg.position.z = result;
            break;
        case 0x10a:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            rmsg.orientation.x = result;
            break;
        // case 0x10b:
        //     std::memcpy(&result, msg->datas.data(), sizeof(double));
        //     rmsg.orientation.y = result;
        //     std::cout <<"0x10b" << std::endl;
        //     // 0x10b有别的程序在发
        //     // ow_recv_time = ros::Time::now().toSec();
        //     break;

        case 0x10c:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            rmsg.orientation.z = result;
            break;
        case 0x10d:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            rmsg.orientation.w = result;
            rack_recv_time = ros::Time::now().toSec();
            break;
        case 0x10e:
            std::memcpy(&result, msg->datas.data(), sizeof(double));
            rmsg.orientation.y = result;
            std::cout <<"0x10e" << std::endl;
            // 0x10b有别的程序在发
            // ow_recv_time = ros::Time::now().toSec();
            break;
    }
    if (fabs(ow_recv_time - px_recv_time) < 0.1)
    {
        // pose_msg.header.stamp = ros::Time::now();
        // static tf::TransformBroadcaster odom_bd;
        // tf::StampedTransform odom_trans;

        // odom_trans.header.stamp = msg->header.stamp;
        // odom_trans.header.frame_id = "pallet_sensor_frame";
        // odom_trans.child_frame_id = "/pallet_link";

        // odom_trans.transform.translation.x = pmsg.position.x;
        // odom_trans.transform.translation.y = pmsg.position.y;
        // odom_trans.transform.translation.z = pmsg.position.z;
        // odom_trans.transform.rotation.x = pmsg.orientation.x;
        // odom_trans.transform.rotation.y = pmsg.orientation.y;
        // odom_trans.transform.rotation.z = pmsg.orientation.z;
        // odom_trans.transform.rotation.w = pmsg.orientation.w;
        // odom_bd.sendTransform(odom_trans);

        static tf::TransformBroadcaster br;
        tf::Transform transform;
        if(check_invalid(pmsg) < 0) {
            std::cout << "pmsg invalid" << std::endl;
            return;
        }
        transform.setOrigin(tf::Vector3(pmsg.position.x, pmsg.position.y, pmsg.position.z) );
        tf::Quaternion q(pmsg.orientation.x,pmsg.orientation.y,pmsg.orientation.z,pmsg.orientation.w);
        transform.setRotation(q);
        br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "pallet_sensor_frame", "pick_fork_reach_point"));

        visualization_msgs::Marker marker;
        marker.header.frame_id = "pallet_sensor_frame";
        marker.header.stamp = ros::Time::now();
        marker.id = 0;
        marker.type = visualization_msgs::Marker::ARROW;
        marker.action = visualization_msgs::Marker::MODIFY;
        marker.pose.position.x = pmsg.position.x;
        marker.pose.position.y = pmsg.position.y;
        marker.pose.position.z = pmsg.position.z;
        marker.pose.orientation.x = q.x();
        marker.pose.orientation.y = q.y();
        marker.pose.orientation.z = q.z();
        marker.pose.orientation.w = q.w();
        marker.scale.x = 0.5; // 柄直径
        marker.scale.y = 0.05;  // 箭头直径
        marker.scale.z = 0.05;   // 长度
        marker.color.r = 0.0;
        marker.color.g = 0.0;
        marker.color.b = 1.0;
        marker.color.a = 1.0;
        marker.lifetime = ros::Duration();
        marker_pub.publish(marker);


        orangepi_can_pub.publish(pmsg);
        set_invalid(pmsg);

    }
    

    if (fabs(rack_recv_time - px_recv_time) < 0.1)
    {
        // pose_msg.header.stamp = ros::Time::now();
        // static tf::TransformBroadcaster odom_bd;
        // tf::StampedTransform odom_trans;

        // odom_trans.header.stamp = msg->header.stamp;
        // odom_trans.header.frame_id = "pallet_sensor_frame";
        // odom_trans.child_frame_id = "/pallet_link";

        // odom_trans.transform.translation.x = pmsg.position.x;
        // odom_trans.transform.translation.y = pmsg.position.y;
        // odom_trans.transform.translation.z = pmsg.position.z;
        // odom_trans.transform.rotation.x = pmsg.orientation.x;
        // odom_trans.transform.rotation.y = pmsg.orientation.y;
        // odom_trans.transform.rotation.z = pmsg.orientation.z;
        // odom_trans.transform.rotation.w = pmsg.orientation.w;
        // odom_bd.sendTransform(odom_trans);

        static tf::TransformBroadcaster br;
        tf::Transform transform;
        if(check_invalid(rmsg) < 0) {
            std::cout << "rmsg invalid" << std::endl;
            return;
        }
        transform.setOrigin(tf::Vector3(rmsg.position.x, rmsg.position.y, rmsg.position.z) );
        tf::Quaternion q(rmsg.orientation.x,rmsg.orientation.y,rmsg.orientation.z,rmsg.orientation.w);
        transform.setRotation(q);
        br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "pallet_sensor_frame", "unpick_fork_reach_point"));

        visualization_msgs::Marker marker;
        marker.header.frame_id = "pallet_sensor_frame";
        marker.header.stamp = ros::Time::now();
        marker.id = 0;
        marker.type = visualization_msgs::Marker::ARROW;
        marker.action = visualization_msgs::Marker::MODIFY;
        marker.pose.position.x = rmsg.position.x;
        marker.pose.position.y = rmsg.position.y;
        marker.pose.position.z = rmsg.position.z;
        marker.pose.orientation.x = q.x();
        marker.pose.orientation.y = q.y();
        marker.pose.orientation.z = q.z();
        marker.pose.orientation.w = q.w();
        marker.scale.x = 0.5; // 柄直径
        marker.scale.y = 0.05;  // 箭头直径
        marker.scale.z = 0.05;   // 长度
        marker.color.r = 0.0;
        marker.color.g = 1.0;
        marker.color.b = 0.0;
        marker.color.a = 1.0;
        marker.lifetime = ros::Duration();
        storage_rack_marker_pub.publish(marker);


        rack_can_pub.publish(rmsg);
        set_invalid(rmsg);
    }
}

void pick_detection_enable_cbk(const std_msgs::Bool::ConstPtr &msg){
    common::can can_msg;
    can_msg.id = 0x210;
    can_msg.len = 8;
    double datas;
    datas = 8;
    unsigned char data_array[8];
    std::memcpy(data_array,reinterpret_cast<unsigned char*>(&datas),8);
    // printf("Data: %d %d %d %d %d %d %d %d\n", 
    // data_array.data[0], data_array.data[1],
    // data_array.data[2], data_array.data[3],
    // data_array.data[4], data_array.data[5],
    // data_array.data[6], data_array.data[7]);
    for(int i = 0;i< 8 ;i++){
        can_msg.datas.push_back(data_array[i]);
    }
    double result;
    std::memcpy(&result,data_array,8);
    std::cout << "result: " << result << std::endl;
    can1_tx_pub.publish(can_msg);
}
void unpick_detection_enable_cbk(const std_msgs::Bool::ConstPtr &msg){
    common::can can_msg;
    can_msg.id = 0x211;
    can_msg.len = 8;
    double datas;
    datas = 8;
    unsigned char data_array[8];
    std::memcpy(data_array,reinterpret_cast<unsigned char*>(&datas),8);

    for(int i = 0;i< 8 ;i++){
        can_msg.datas.push_back(data_array[i]);
    }
    can1_tx_pub.publish(can_msg);
}
int main(int argc, char *argv[])
{
    ros::init(argc, argv, "orangepi_cannode");
    ros::NodeHandle nh;
    ros::NodeHandle nh_priv("~");
    orangepi_can_pub = nh_priv.advertise<geometry_msgs::Pose>("/pallet_pose", 10);
    marker_pub = nh_priv.advertise<visualization_msgs::Marker>("/pallet_pose_marker", 1);
    storage_rack_marker_pub = nh_priv.advertise<visualization_msgs::Marker>("/storage_rack_pose_marker", 1);
    rack_can_pub = nh_priv.advertise<geometry_msgs::Pose>("/storage_rack_pose", 10);
    can1_rx_sub = nh_priv.subscribe("/can1_rx", 100, handle_orangepi_candata);
    can1_tx_pub = nh_priv.advertise<common::can>("/can1_tx", 10);
    pick_detection_enable_sub_ =
        nh_priv.subscribe("/pick_detection_enable", 1, pick_detection_enable_cbk);
    unpick_detection_enable_sub_ =
        nh_priv.subscribe("/unpick_detection_enable", 1, unpick_detection_enable_cbk);
    ow_recv_time=ros::Time::now().toSec();
    set_invalid(rmsg);
    set_invalid(pmsg);
    ros::spin();
    return 0;
}